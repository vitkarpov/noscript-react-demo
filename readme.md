```
$ npm install && npm run build
```

> вьюшка App и выполняет роль лейаута, получая в пропсы страницу и параметры.

[Пруф оф консепт](https://vitkarpov.github.io/noscript-react-demo/)

Все, что необходимо, это:

```js
ns.page.startUpdate = function(route) {
    ReactDOM.render(
        <App ...route />, document.getElementById('app')
    );
}
```

## Как сделана интеграция ns и react сейчас

Есть классы вьюшек `ns.ViewReact, ns.BoxReact, ...`, которые встраиваются в текущее поведение ns-апдейта. Начиная с какого-то момента вьюшки рисуются уже полностью в виртуальном доме.

Чем не нравится это решение? Основная проблема в том, что появляется два апдейта: ноускриптовый и реактовый:

- хочется дернуть `setState` у вьюшки, но нельзя — она валидная и с точки зрения ns не нужно ничего перерисовывать (что выносит мозг с реактом)
- сложный алгоритм определения `selfValid` у вьюшки: приходится постоянно спускать вниз по дереву и смотреть есть ли невалидные детки, если так, то помечать родительскую вьюшку как невалидную, потому что если дальше нее апдейте не пойдет, то и детки не перерисуются

Создается впечатление, что ns апдейт вовсе лишний. Он нужен:

- чтобы запросить все синхронные модельки
- чтобы создавать правильные экземпляры вьюшек и рисовать их в определенных местах (в том числе и динамически, с помощью боксов)

Со второй задачей отлично справляется реакт.

## Как хочется сделать интеграцию ns и react

Разделить ns и реакт более явно:

- ns занимается роутингом и данными (умеет запрашивать, кешировать, ns.Model.get)
- ns.page.go по ссылкам (но без ns-апдейта!)
- экшены

- реакт занимается отрисовкой **всего дерева самостоятельно**

## Что необходимо для такой интеграции

- придумать связь между вьюшками и моделями: по аналогии с редаксом это может быть некий HOC (назовем его DataProvider), который принимает айдишники и параметры моделей, достает нужны экземпляры и дергает своих деток, передавая им некий стейт
- придумать механизм запроса моделей по реактивному лейауту: DataProvider, понимая, что моделька невалидная, ставит ее в общую очередь запросов (единая, чтобы сохранить балковость запросов), по-прежнему рисует своих деток, но в стейте они, например, получают соответствующий флажок о состоянии модели, чтобы детки сами решили как им рисоваться (или не рисоваться)

## Смена парадигмы изменения моделей для перерисовок

Сейчас вьюшки подписываются на изменения моделей и дергают апдейт. В простом случае это ок, но в больших приложениях при появлении разных связей между моделями (она модель меняют другую, та асинхронно меняет третью и т.д.) получаем **каскад апдейтов** с непредсказуемым порядком.

Соответственно, при различных накликиваниях в интерфейсе итоговый апдейт становится непредсказуемым и **нетестируемым** (не воспроизводимым однозначно в тесте).

Хочется действовать в лучших традициях редакса:

- все, что может менять интерфейс называется экшенами и выносится в ns.action.define
- вьюшки **не могут менять модели напрямую** и не подписываются на их изменения (DataProvider получается простой как палка)
- вьюшки дергают экшены
- экшены получают все необходимые параметры, чтобы найти нужные экземпляры моделей, модели меняются и когда мы уверены, что все данные консистенты (в том числе и после асинхронных действий)
— запускаем ns.page.go в конце экшена
- снова приходим в `ReactDOM.render(<APP />)` и происходит апдейт от корня
